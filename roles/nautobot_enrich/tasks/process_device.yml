---
# Expects:
#   dev: { ip: "x.x.x.x" }
#   nautobot_url, nautobot_token, nautobot_namespace, nautobot_depth
# Optional:
#   nautobot_enrich_include:
#     device_name: true
#     interface_name: true
#     device_id: false
#     interface_id: false

# 1) Look up this IP in Nautobot (raw result, with depth so we can see device/interface)
- name: Lookup IP in Nautobot
  vars:
    ip: "{{ dev.ip }}"
    filter_query: "address={{ ip }} namespace={{ nautobot_namespace }}"
    depth_suffix: " depth={{ nautobot_depth | default(2) }}"
  ansible.builtin.set_fact:
    _ip_lookup_raw: >-
      {{
        lookup(
          'networktocode.nautobot.lookup',
          'ip-addresses',
          api_filter=(filter_query ~ depth_suffix),
          api_endpoint=nautobot_url,
          token=nautobot_token,
          raw_data=True,
          num_retries=3
        )
        | default({})
      }}
  delegate_to: localhost

# 2) Normalize the lookup to a list so we can safely index the "first match"
- name: Normalize lookup to a list
  ansible.builtin.set_fact:
    _ip_list: >-
      {{
        [_ip_lookup_raw] if (_ip_lookup_raw is mapping)
        else (_ip_lookup_raw
              if (_ip_lookup_raw is iterable and not (_ip_lookup_raw is string))
              else [])
      }}
  delegate_to: localhost

# 3) Choose the "primary" object (first match) or {}
- name: Pick first result (if any)
  ansible.builtin.set_fact:
    _nb_ip: "{{ _ip_list[0] if (_ip_list | length) > 0 else {} }}"
  delegate_to: localhost

# 4) Extract attributes in one place (easy to extend later)
#    We try assigned_object first, then fall back to the first interface entry.
- name: Derive device and interface attributes from Nautobot result
  vars:
    _dev_name_assigned: >-
      {{
        _nb_ip.assigned_object.device.name
        if (_nb_ip != {}
            and _nb_ip.assigned_object is defined and _nb_ip.assigned_object
            and _nb_ip.assigned_object.device is defined and _nb_ip.assigned_object.device
            and _nb_ip.assigned_object.device.name is defined)
        else None
      }}
    _dev_name_iface: >-
      {{
        _nb_ip.interfaces[0].device.name
        if (_nb_ip != {}
            and _nb_ip.interfaces is defined and (_nb_ip.interfaces | length) > 0
            and _nb_ip.interfaces[0].device is defined and _nb_ip.interfaces[0].device
            and _nb_ip.interfaces[0].device.name is defined)
        else None
      }}
    device_name: "{{ _dev_name_assigned if _dev_name_assigned else _dev_name_iface }}"
    _if_name_assigned: >-
      {{
        _nb_ip.assigned_object.name
        if (_nb_ip != {}
            and _nb_ip.assigned_object is defined and _nb_ip.assigned_object
            and _nb_ip.assigned_object.name is defined)
        else None
      }}
    _if_name_iface: >-
      {{
        _nb_ip.interfaces[0].name
        if (_nb_ip != {}
            and _nb_ip.interfaces is defined and (_nb_ip.interfaces | length) > 0
            and _nb_ip.interfaces[0].name is defined)
        else None
      }}
    interface_name: "{{ _if_name_assigned if _if_name_assigned else _if_name_iface }}"
    _dev_id_assigned: >-
      {{
        _nb_ip.assigned_object.device.id
        if (_nb_ip != {}
            and _nb_ip.assigned_object is defined and _nb_ip.assigned_object
            and _nb_ip.assigned_object.device is defined and _nb_ip.assigned_object.device
            and _nb_ip.assigned_object.device.id is defined)
        else None
      }}
    _dev_id_iface: >-
      {{
        _nb_ip.interfaces[0].device.id
        if (_nb_ip != {}
            and _nb_ip.interfaces is defined and (_nb_ip.interfaces | length) > 0
            and _nb_ip.interfaces[0].device is defined and _nb_ip.interfaces[0].device
            and _nb_ip.interfaces[0].device.id is defined)
        else None
      }}
    device_id: "{{ _dev_id_assigned if _dev_id_assigned else _dev_id_iface }}"
    interface_id: >-
      {{
        _nb_ip.assigned_object.id
        if (_nb_ip != {}
            and _nb_ip.assigned_object is defined and _nb_ip.assigned_object
            and _nb_ip.assigned_object.id is defined)
        else (
          _nb_ip.interfaces[0].id
          if (_nb_ip != {}
              and _nb_ip.interfaces is defined and (_nb_ip.interfaces | length) > 0
              and _nb_ip.interfaces[0].id is defined)
          else None
        )
      }}
  ansible.builtin.set_fact:
    _nb_attrs:
      device_name: "{{ device_name }}"
      interface_name: "{{ interface_name }}"
      device_id: "{{ device_id }}"
      interface_id: "{{ interface_id }}"
  delegate_to: localhost

# 5) Build the output device dict for this hop.
#    Use 'nautobot_enrich_include' toggles so adding fields is just one more combine.
- name: Build new device payload (ip + optional fields)
  vars:
    _inc: "{{ nautobot_enrich_include | default({'device_name': true, 'interface_name': true}) }}"
  ansible.builtin.set_fact:
    _new_device: >-
      {{
        {'ip': dev.ip}
        | combine( {'device_name': _nb_attrs.device_name} if (_inc.device_name | default(true)) and _nb_attrs.device_name else {} )
        | combine( {'interface_name': _nb_attrs.interface_name} if (_inc.interface_name | default(true)) and _nb_attrs.interface_name else {} )
        | combine( {'device_id': _nb_attrs.device_id} if (_inc.device_id | default(false)) and _nb_attrs.device_id else {} )
        | combine( {'interface_id': _nb_attrs.interface_id} if (_inc.interface_id | default(false)) and _nb_attrs.interface_id else {} )
      }}
  delegate_to: localhost

# 6) Append to this hop's device accumulator
- name: Append device to tmp_devices
  ansible.builtin.set_fact:
    tmp_devices: "{{ (tmp_devices | default([])) + [_new_device] }}"
  delegate_to: localhost
